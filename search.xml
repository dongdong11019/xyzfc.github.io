<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PHP foreach循环使用&引用的小坑]]></title>
    <url>%2F2019%2F08%2F07%2FPHP-foreach%E5%BE%AA%E7%8E%AF%E4%BD%BF%E7%94%A8-%E5%BC%95%E7%94%A8%E7%9A%84%E5%B0%8F%E5%9D%91%2F</url>
    <content type="text"><![CDATA[源起：今天有小🔥伴发了一段 PHP 代码问执行结果和常规逻辑思考🤔结果为啥么不一样。代码如下，当时只是说和 foreach 使用 &amp; 有关。也没深入思考到底是什么关系，午睡过后，心血来潮的想搞搞这个问题，故做如下记录。 小伙伴给的原始代码如下 123456789101112131415161718&lt;?php $arr = [1, 2, 4, 8]; foreach ($arr as &amp;$val) &#123; //四次循环迭代后依次输出 1, 2, 4, 8; 没任何毛病 echo $val . PHP_EOL; &#125; print_r($arr); echo "************************" . PHP_EOL; foreach ($arr as $val) &#123; print_r($arr); echo $val . PHP_EOL; echo "###################" . PHP_EOL; &#125; //echo 依次打印的是： 1，2，4，4 [(O_O)]? 代码执行结果如下图 那么问题来了，第一次输出 1，2，4，8 没有任何问题。但是，但是，但是为什么第二次输出的是 1, 2, 4, 4 而不是 1、2 4、8 呢？查询 PHP foreach 文档 有辣么一句特别提醒 Warning 数组最后一个元素的 $value 引用在 foreach 循环之后仍会保留。建议使用 unset() 来将其销毁。看此提示，冥冥之中好像知道了答案。 第一次 foreach 由于使用的是 &amp; 引用赋值，在循环完成后如果没有 unset($val) 会保留最后一个元素的 $val引用 第二次 foreach 由于使用的和第一次同样的迭代变量 $val, 数组的最后一个元素 $arr[3] 和当前循环迭代值 $val 指向同一个变量地址，此时 $val 值改变时 $arr[3] 的值也跟着改变了。 用上图说明 原始数组为图中 A区域 数组 第 0 次循环迭代：最后一个元素 $arr[3] 和 $val 即($arr[0]) 值相同。$arr[3] = $val = 1，如图中 0区域 12345678Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 4 [3] =&gt; 1)第0次循环结果：1 第 1 次循环迭代：最后一个元素 $arr[3] 和 $val 即($arr[1]) 值相同。$arr[3] = $val = 2，如图中 1区域 12345678Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 4 [3] =&gt; 2)第1次循环结果：2 第 2 次循环迭代：最后一个元素 $arr[3] 和 $val 即($arr[2]) 值相同。$arr[3] = $val = 4，如图中 2区域 12345678Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 4 [3] =&gt; 4)第2次循环结果：4 第 3 次循环迭代：最后一个元素 $arr[3] 和 $val 即($arr[3]) 值相同。$arr[3] = $val = 4，如图中 3区域 12345678Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 4 [3] =&gt; 4)第2次循环结果：4 综上，第二次循环 1, 2, 4, 4 就是这么来的 😜]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[golang爬取百度贴吧内容]]></title>
    <url>%2F2019%2F08%2F04%2Fgolang%E7%88%AC%E5%8F%96%E7%99%BE%E5%BA%A6%E8%B4%B4%E5%90%A7%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[爬虫实现步骤1：获取需要爬取URL的地址（以 JavaScript吧 举例） http://tieba.baidu.com/f?kw=javascript&amp;ie=utf-8&amp;pn=0 http://tieba.baidu.com/f?kw=javascript&amp;ie=utf-8&amp;pn=50 http://tieba.baidu.com/f?kw=javascript&amp;ie=utf-8&amp;pn=1502：使用 http.Get(url) 获取到每一个URL的内容 3：将或得到URL的内容写入文件 注意文件命名 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102package mainimport ( "fmt" "net/http" "io" "strconv" "os" "time")//贴吧的URL//http://tieba.baidu.com/f?kw=javascript&amp;ie=utf-8&amp;pn=0//http://tieba.baidu.com/f?kw=javascript&amp;ie=utf-8&amp;pn=50func main() &#123; start := time.Now() //确认起始页和终止页 var startPage int var endPage int fmt.Print("请输入起始页:") fmt.Scanln(&amp;startPage) if startPage &lt;= 1 &#123; startPage = 1 &#125; fmt.Print("请输入终止页:") fmt.Scanln(&amp;endPage) if endPage &lt;= 1 &#123; endPage = 1 &#125; working(startPage, endPage) cost := time.Since(start) fmt.Printf("耗时 = [%s] ", cost)&#125;func working(startPage, endPage int) &#123; fmt.Printf("正在爬取第%d页到%d页的信息...\n", startPage, endPage) pageChan := make(chan int) //循环爬取每一页 for i := startPage; i &lt;= endPage; i++ &#123; //开启协程 go SpiderPage(i, pageChan) //SpiderPage(i, pageChan) &#125; for i := startPage; i &lt;= endPage; i++ &#123; //开启协程 fmt.Printf("第 %d 页 爬取完成\n", &lt;-pageChan) &#125;&#125;//爬取单个页面的函数func SpiderPage(i int, pageChan chan int) &#123; baseUrl := "http://tieba.baidu.com/f?kw=javascript&amp;ie=utf-8&amp;pn=" + strconv.Itoa((i-1)*50) fmt.Println("正在获取第", i, "页的内容") result, err := httpGetUrl(baseUrl) if err != nil &#123; fmt.Println("http get error, Msg", err.Error()) return &#125; //将读取到的数据存储存储为文件 file, err := os.Create("JavaScript_" + strconv.Itoa(i) + ".html") if err != err &#123; fmt.Println("os Create err：", err.Error()) return &#125; file.WriteString(result) file.Close() //保存好一个文件就关闭一个文件 pageChan &lt;- i&#125;//爬取内容func httpGetUrl(url string) (result string, err error) &#123; resp, err1 := http.Get(url) if err1 != nil &#123; err = err1 return &#125; //关闭 defer resp.Body.Close() //读取数据 buffer := make([]byte, 8196) for &#123; //读取的内容至于buffer容器 n, err2 := resp.Body.Read(buffer) if n == 0 &#123; fmt.Println("读取网页完成") break &#125; if err2 != nil &amp;&amp; err2 != io.EOF &#123; err = err2 return &#125; //累次相加每一次读到的Buffer数据，存入result, 一次性返回 result += string(buffer[:n]) &#125; return`]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员数学基础 之 矩阵]]></title>
    <url>%2F2019%2F08%2F03%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[1：矩阵相加 2：矩阵相乘（不符合交换律） 标量 * 矩阵 变量 * 矩阵的每一个元素，得到一个新矩阵 矩阵 * 矩阵 用矩阵的 第1行 分别去 乘以 矩阵的每一列 用矩阵的 第N行 分别去 乘以 矩阵的每一列 - 矩阵A * 矩阵B != 矩阵B * 矩阵A 矩阵相乘的条件：前面矩阵的列数 等于 后面矩阵的行数]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test article]]></title>
    <url>%2F2019%2F08%2F02%2Fpost-test-deploy-hexo%2F</url>
    <content type="text"><![CDATA[Hexo 部署测试1：通过日志方式统计 1234567file_put_contents("loc.log", microtime(true).'_end'."-----$lat@2".PHP_EOL, FILE_APPEND);file_put_contents('exelog/'.time().'.log', var_export(Yii::$app-&gt;request-&gt;post(), true));$postdata = file_get_contents("php://input");$postdata = json_decode($postdata,true); 2：二维数组指定字段排序12345array_multisort (array_column($citiesMddBaseInfo, ‘hot’), SORT_DESC, $citiesMddBaseInfo);array_multisort(array_column($hotelList, 'price'), SORT_ASC, $hotelList);array_multisort($hotelList,SORT_ASC, array_column($hotelList, 'price'));]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
