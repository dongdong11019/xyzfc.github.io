<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[golang爬取百度贴吧内容]]></title>
    <url>%2F2019%2F08%2F04%2Fgolang%E7%88%AC%E5%8F%96%E7%99%BE%E5%BA%A6%E8%B4%B4%E5%90%A7%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[爬虫实现步骤1：获取需要爬取URL的地址（以JavaScript举例） http://tieba.baidu.com/f?kw=javascript&amp;ie=utf-8&amp;pn=0 http://tieba.baidu.com/f?kw=javascript&amp;ie=utf-8&amp;pn=50 http://tieba.baidu.com/f?kw=javascript&amp;ie=utf-8&amp;pn=1502：使用 http.Get(url) 获取到每一个URL的内容 3：将或得到URL的内容写入文件 注意文件命名 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485package mainimport ( &quot;fmt&quot;4&quot;strconv&quot;4&quot;net/http&quot;4&quot;io&quot;4&quot;os&quot;)//贴吧的URL//http://tieba.baidu.com/f?kw=javascript&amp;ie=utf-8&amp;pn=0//http://tieba.baidu.com/f?kw=javascript&amp;ie=utf-8&amp;pn=50func main() &#123;4//确认起始页和终止页4var startPage int4var endPage int4fmt.Print(&quot;请输入起始页:&quot;)4fmt.Scanln(&amp;startPage)4if startPage &lt;= 1 &#123;44startPage = 14&#125;4fmt.Print(&quot;请输入终止页:&quot;)4fmt.Scanln(&amp;endPage)4if endPage &lt;= 1 &#123;44endPage = 14&#125;4working(startPage, endPage)&#125;func working(startPage, endPage int) &#123;4//fmt.Println(startPage, endPage)4fmt.Printf(&quot;正在爬取第%d页到%d页的信息...\n&quot;, startPage, endPage)4//循环爬取每一页4baseUrl := &quot;http://tieba.baidu.com/f?kw=javascript&amp;ie=utf-8&amp;pn=&quot;4for i := startPage; i &lt;= endPage; i++ &#123;44pageNum := (i - 1) * 5044crawlerUrl := baseUrl + strconv.Itoa(pageNum)44result, err := httpGetUrl(crawlerUrl)44if err != nil &#123;444fmt.Println(&quot;http get error, Msg&quot;, err.Error())444continue44&#125;44//将读取到的数据存储存储为文件44file, err := os.Create(&quot;JavaScript_&quot; + strconv.Itoa(i) + &quot;.html&quot;)44if err != err &#123;444fmt.Println(&quot;os Create err：&quot;, err.Error())444continue44&#125;44file.WriteString(result)44file.Close() //保存好一个文件就关闭一个文件4&#125;&#125;//爬取内容func httpGetUrl(url string) (result string, err error) &#123;4resp, err1 := http.Get(url)4if err1 != nil &#123;44err = err144return4&#125;4//关闭4defer resp.Body.Close()4//读取数据4buffer := make([]byte, 8196)4for &#123;44//读取的内容至于buffer容器44n, err2 := resp.Body.Read(buffer)44if n == 0 &#123;444fmt.Println(&quot;读取网页完成&quot;)444break44&#125;44if err2 != nil &amp;&amp; err2 != io.EOF &#123;444err = err2444return44&#125;44//累次相加每一次读到的Buffer数据，存入result, 一次性返回44result += string(buffer[:n])4&#125;4return&#125;]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员数学基础 之 矩阵]]></title>
    <url>%2F2019%2F08%2F03%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[1：矩阵相加 2：矩阵相乘（不符合交换律） 标量 * 矩阵 变量 * 矩阵的每一个元素，得到一个新矩阵 矩阵 * 矩阵 用矩阵的 第1行 分别去 乘以 矩阵的每一列 用矩阵的 第N行 分别去 乘以 矩阵的每一列 - 矩阵A * 矩阵B != 矩阵B * 矩阵A 矩阵相乘的条件：前面矩阵的列数 等于 后面矩阵的行数]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test article]]></title>
    <url>%2F2019%2F08%2F02%2Fpost-test-deploy-hexo%2F</url>
    <content type="text"><![CDATA[Hexo 部署测试1：通过日志方式统计 1234567file_put_contents("loc.log", microtime(true).'_end'."-----$lat@2".PHP_EOL, FILE_APPEND);file_put_contents('exelog/'.time().'.log', var_export(Yii::$app-&gt;request-&gt;post(), true));$postdata = file_get_contents("php://input");$postdata = json_decode($postdata,true); 2：二维数组指定字段排序12345array_multisort (array_column($citiesMddBaseInfo, ‘hot’), SORT_DESC, $citiesMddBaseInfo);array_multisort(array_column($hotelList, 'price'), SORT_ASC, $hotelList);array_multisort($hotelList,SORT_ASC, array_column($hotelList, 'price'));]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
